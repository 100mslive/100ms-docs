---
title: Getting Started - Android
nav: 10
---

## Introduction

This guide provides an overview of the key objects you'll use with 100ms Android SDK to build a live audio/video application

> If you haven't already done so, try our sample [quickstart app](https://github.com/100mslive/100ms-android). Then you can come back later to see how to build your own live audio/video app in more detail

## Supported Devices

100ms' Android SDK supports Android API level 21 and higher. It is built for armeabi-v7a, arm64-v8a, x86, and x86_64 architectures

## Concepts

-   `Room` - A room represents real-time audio, video session, the basic building block of the 100mslive Video SDK
-   `Track` - A track represents either the audio or video that makes up a stream
-   `Peer` - A peer represents all participants connected to a room. Peers can be "local" or "remote"
-   `Broadcast` - A local peer can send any message/data to all remote peers in the room

## Pre-requisites

### 1. Add dependency to 100ms lib

-   Add the JitPack repository to your build file. Add it in your root `build.gradle` at the end of repositories of `allprojects`:

```json
allprojects {
		repositories {
			...
			maven { url 'https://jitpack.io' }
		}
	}
```

-   Add the dependency in your app-level `gradle` [![](https://jitpack.io/v/100mslive/android-sdk.svg)](https://jitpack.io/#100mslive/android-sdk)

```json
dependencies {
		implementation 'com.github.100mslive:android-sdk:x.x.x'
	}
```

### 2. Add other dependencies

Add all the following libraries in your app-level Gradle file as dependencies.

-   If you are using any of the following libraries already in your application, you can use the version you are already using.
-   Make sure `okhttp` and `webrtc` use the same version as mentioned below

```bash
implementation 'org.webrtc:google-webrtc:1.0.32006'
implementation 'com.squareup.okhttp3:okhttp:3.6.0'
implementation 'com.google.code.gson:gson:2.8.6'
implementation 'org.jetbrains:annotations:15.0'
```

### 3. Generate token

Please use the [100ms quickstart app server](/v2/server-side/100ms-quickstart-app-server) to get `TOKEN_ENDPOINT`

Put your endpoint URL as `TOKEN_ENDPOINT` in `app/gradle.properties`

Make sure it ends with a backslash \(`/`\) For example:

```
TOKEN_ENDPOINT="https://example-tokenservice.runkit.sh/" # Valid
TOKEN_ENDPOINT="https://example-tokenservice.runkit.sh" # Invalid
```

## Create and instantiate 100ms SDK

To start using 100ms SDK first, the SDK needs to be built using the required configurations that you want. Advanced configurations include -

-   `HMSTrackSettings` - to specify any `Track` settings that may be different from the default. If not set, HMSSDK will use the default values.
-   `HMSLogger.LogLevel` - to specify the log level needed. Default value is `DEBUG`
-   `AnalyticEventLevel` - to specify the event level of analytics to be sent. Default value is `ERROR`

```java
val hmsSDK = HMSSDK
    .Builder(application) // pass the application context
    .setTrackSettings(hmsTrackSettings) // optional -- to set a track settings different from default
    .setAnalyticEventLevel(HMSAnalyticsEventLevel.ERROR) // optional -- set the analytical level
    .setLogLevel(HMSLogger.LogLevel.VERBOSE) // optional -- set the logging level
    .build()
```

> Just `HMSSDK.Builder(application).build()` should work for most cases.

## Provide joining configuration

To join a room created by following the steps described [in this section](/v2/server-side/Create-room), clients need to create a `HMSConfig` instance and use that instance to call `join` method of `HMSSDK` .

```java
// Create a new HMSConfig
val config = HMSConfig(
        username, // the name that the user wants to be displayed while in the room
        authToken, // the auth token to be used
        description, // optional -- any  json string or metadata that user need to paas while joining
        endpoint // optional -- to override the default endpoint (advanced)
      )


```

## Add event listeners

100ms SDK provides callbacks to the client app about any change or update happening in the room after a user has joined by implementing `HMSUpdateListener` . These updates can be used to render the video on screen or to display other info regarding the room.

```java
      val hmsUpdateListener = object: HMSUpdateListener{

        override fun onJoin(room: HMSRoom) {
          // This will be called on a successful JOIN of the room by the user
          // This is the point where applications can stop showing its loading state
        }

        override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
          // This will be called whenever there is an update on an existing peer
          // or a new peer got added/existing peer is removed.
          // This callback can be used to keep a track of all the peers in the room
        }

        override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {
          // This is called when there is a change in any property of the Room
        }

        override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
          // This is called when there are updates on an existing track
          // or a new track got added/existing track is removed
          // This callback can be used to render the video on screen whenever a track gets added
        }

        override fun onMessageReceived(message: HMSMessage) {
          // This is called when there is a new broadcast message from any other peer in the room
          // This can be used to implement chat is the room
        }

        override fun onError(error: HMSException) {
          // This will be called when there is an error in the system
          // and SDK has already retried to fix the error
        }

        override fun onReconnecting(error: HMSException) {
          // This is called when connection reestablishment starts
          // This can be used to show a loading notification in the UI
          // Parameter error: the error from the action that failed and caused the connection reestablishment
        }
    
        override fun onReconnected() {
          // This is called when the connection reestablishment completed susccessfully
        }

      }
```

## How to listen to Track, Peer and Room updates

The `HMS` SDK sends updates to the application about any change in `HMSPeer` , `HMSTrack` or `HMSRoom` via the callbacks in `HMSUpdateListener` . Application need to listen to the corresponding updates in `onPeerUpdate` , `onTrackUpdate` or `onRoomUpdate`

The following are the different types of updates that are emitted by the SDK

```
HMSPeerUpdate
    case PEER_JOINED - A new peer joins the room
    case PEER_LEFT - An existing peer leaves the room
    case BECAME_DOMINANT_SPEAKER - A peer becomes a dominant speaker
    case NO_DOMINANT_SPEAKER - There is silence in the room (No speaker is detected)

HMSTrackUpdate
    case TRACK_ADDED - A new track is added by a remote peer
    case TRACK_REMOVED - An existing track is removed from a remote peer
    case TRACK_MUTED - An existing track of a remote peer is muted
    case TRACK_UNMUTED - An existing track of a remote peer is unmuted
    case TRACK_DESCRIPTION_CHANGED - The optional description of a track of a remote peer is changed
```

## How to use Preview API

`HMSSDK` provides a `preview` API which can be used by client apps to show preview screnn of the camera device being used to capture the video. Calling this API also means the SDK makes sure that there is a valid network path between the client and the servers. The token used is also validated in this. 

```
// Call the preview api by passing the config object
sdk.preview(config: HMSConfig, listener: HMSPreviewListener)

interface HMSPreviewListener {
	/** Send the list of local tracks which can be shown in a Preview Screen
	 * Here, room can be used to get all peers already in the room
	*/
	override onPreview(room: HMSRoom, localTracks: Array<HMSTrack>)
	/** Call Error on case of any errors happening during the INIT call, 
	 * websocket connection creation or network
	*/
	override onError(error: HMSException)
}
```
Please note that `hmsSDK.leave()` should be called while navigating back from the preview screen to cleanup the websockets that are being open. 


## How to know the type and source of Track

`HMSTrack` contain a field called `source` which denotes the source of the Track. `source` can have the following values - `regular` \(normal\), `screen` \(for screenshare\)and `plugin` \(for plugins\)

To know the type of track, check the value of `type` which would be one of the enum values - `AUDIO` or `VIDEO`

## Join room

Use the `HMSConfig` and `HMSUpdateListener` instances to call `join` method on the instance of `HMSSDK` created above.

Once `Join` succeeds, all the callbacks keep coming on every change in the room and the app can react accordingly

```java
hmsSDK.join(hmsConfig, hmsUpdateListener) // to join a room
```

## Leave room

Call the `leave` method on the `HMSSDK` instance

```java
hmsSDK.leave() // to leave a room
```

## Get peers/tracks data

`HMSSDK` has other methods which the client app can use to get more info about the `Room` , `Peer` and `Tracks`

```java
    fun join(config: HMSConfig, hmsUpdateListener: HMSUpdateListener) {
        // to join a Room
    }

    fun leave() {
        // to leave a Room
    }

    fun getLocalPeer(): HMSPeer {
        // Returns the local peer, which contains the local tracks
    }

    fun getRemotePeers(): List<HMSPeer> {
        // Returns a list of all the remote peers present in the room currently
    }

    fun getPeers(): List<HMSPeer> {
        // Returns a list of all the peers present in the room currently
    }

    fun sendMessage(type: String, message: String) {
        // used to send message to all other peers via broadcast
    }

    fun addAudioObserver(observer: HMSAudioListener) {
        // add a observer to listen to Audio Level Info of all peers. This will be
        // called every second if set
    }

    fun removeAudioObserver() {
        // remove the audio level info observer
    }
```

## HMSTracks explained

`HMSTrack` is the super class of all the tracks that are used inside `HMSSDK` . Its hierarchy looks like this

-   `HMSTrack`
    -   `HMSAudioTrack`
        -   `HMSLocalAudioTrack`
        -   `HMSRemoteVideoTrack`
    -   `HMSVideoTrack`
        -   `HMSLocalVideoTrack`
        -   `HMSRemoteVideoTrack`

```java
    class HMSTrack {
        val trackId: String // This is the id of a given track
        val type: HMSTrackType // One of AUDIO or VIDEO
        var source: String // This denotes whether the given track is a `regular`, `screen` or `plugin` type
        var description: String // This can be set by client app while creating a HMSTrack. Default value is empty
        var isMute: Boolean // This denotes where the current track is mute or not
    }

    class HMSLocalAudioTrack {
        var volume: Double // Volume of the current Track
        val hmsAudioTrackSettings: HMSAudioTrackSettings // Settings of the given Audio Track
        fun setMute(isMute: Boolean) // to mute or unmute the local audio track
        fun setSettings(newSettings: HMSAudioTrackSettings) // Application can use this to change settings of the audio track.
    }

    class HMSRemoteAudioTrack {
        var isPlaybackAllowed: Boolean // Is local playback allowed of this track or not

        fun setVolume(value: Double) // method to set the playback volume of remote audio track
    }

    class HMSVideoTrack {
        fun addSink(sink: VideoSink) // Call this when app needs to render a track on screen
        fun removeSink(sink: VideoSink) // Call this when app no longer needs to rebder
    }

    class HMSLocalVideoTrack {
        fun setMute(isMute: Boolean) // to mute or unmute the local video track
        fun setSettings(newSettings: HMSVideoTrackSettings) // to set new settings
        fun switchCamera() // To switch camera
        fun switchCamera(deviceId: String) // to change to a particular camera
    }

    class HMSRemoteVideoTrack {
        var isPlaybackAllowed: Boolean // to set or get if local playback is allowed for the remote video track
    }

    enum class HMSTrackType {
        AUDIO, // Denotes AUDIO track
        VIDEO  // Denotes VIDEO track
    }

```
