---
title: Quickstart - Android
nav: 10
---

## Introduction

Welcome to 100ms!

100ms makes an SDK (for android, ios and web) to abstract away the complexities of video conferencing. It helps  you to build your own video conferencing app.

Note: This is the guide for joining rooms without roles. For the meeting links created from the dashboard and not a custom server implementation.

## How it works end to end

This guide will help you create your own stunning video/audio conferencing app.

Here's an overview of what you'd do to get video conferencing working end to end.

1. Add the SDK to your app.
2. Build out the login and video room activities.
3. Sign up for your own dashboard @ [100ms](https://dashboard.100ms.live/register) to create meeting links.
    - Everyone who opens the link (from the app built with the SDK) joins the same video chat.

You can see the simplest android app repo that does this [here](https://github.com/100mslive/hello-world-android/).
Or see one with all the advanced features that 100ms has to offer [here](https://github.com/100mslive/100ms-android).

If you were looking for an audio and video preview after the login but before the video call, 100ms provides an API for that too. It's called the preview API and you'll find more info about it here [todo add link].

## Supported Android API Levels

100ms' Android SDK supports Android API level 21 and higher. It is built for armeabi-v7a, arm64-v8a, x86, and x86_64 architectures.

## Building the app

### Adding the SDK

#### 1. Add dependency to 100ms lib

-   Add the JitPack repository to your build file. Add it in your root `build.gradle` at the end of repositories of `allprojects`:

```json
allprojects {
		repositories {
			...
			maven { url 'https://jitpack.io' }
		}
	}
```
[todo mention that it needs to be added to settings.gradle instead]

-   Add the 100ms sdk dependency to your app-level `gradle` [![](https://jitpack.io/v/100mslive/android-sdk.svg)](https://jitpack.io/#100mslive/android-sdk)

```json
dependencies {
        // See the version in the jitpack badge above.
		implementation 'com.github.100mslive:android-sdk:x.x.x' 
	}
```

### 2. Add other dependencies

Add all the following libraries in your app-level Gradle file as dependencies.

-   If you are already using any of the following libraries (except for webrtc) in your application, you don't need to change the versions.
-   Make sure `webrtc` uses the same version as below.

```bash
implementation 'org.webrtc:google-webrtc:1.0.32006'
implementation 'com.squareup.okhttp3:okhttp:4.9.1'
implementation 'com.google.code.gson:gson:2.8.6'
implementation 'org.jetbrains:annotations:15.0'
```

That's the bare minimum, if you want to follow along with how to build an app you'll also need:

```bash
    // 100ms
    implementation 'org.webrtc:google-webrtc:1.0.32006'
    implementation 'com.github.100mslive:android-sdk:2.0.5' 

    // Networking
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation "com.squareup.okhttp3:okhttp:4.9.1"
    implementation 'com.google.code.gson:gson:2.8.7'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'

    // Background handling
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'

    // Viewmodel
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1"
    // for by viewModels
    implementation "androidx.activity:activity-ktx:1.2.4"

    // Livedata
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.3.1"
```

### 3. Sign up to the dashboard

You'll need a 100ms account to create video rooms for you to join with the app.

[Sign up](https://dashboard.100ms.live/register) for an account. Be sure to create a video conferencing room and take note of the url. 

This is what we'll call the video call url and it should look something like this. https://yourname.app.100ms.live/preview/snippy-purple-mouse
<!-- [todo add video here] -->
<!-- ![](/docs/v2/getting-started-android/new-project-type.png) -->

## Create and instantiate 100ms SDK

To use the SDK methods, create an instance via the builder. Here's the simplest way.
```kotlin
val hmsSDK = HMSSDK
    .Builder(application) // pass the application context
    .build()
```

Advanced configurations can be seen at: [todo api reference].

## Joining a video call

To join a video chat you need to call the `join` method on HMSSDK. This method takes two parameters.
1. The HMSConfig (which contains username and authentication token as required parameters though advanced ones exist).
2. The HMSUpdateListeners which let you know when people join or leave or other things happen in the video chat.

It would look like:

```kotlin

    hmsSDK.join(hmsConfig, hmsUpdateListeners)

```

Let's see how to get instances of these objects.

#### Getting the HMSConfig ready

The only required fields in HMSConfig are username and authToken.

Username:
This can be whatever the user decides. Take it in a login form.

Auth Token:
A new auth token should be requested each time a call is joined.

The auth token API call is a HTTP POST call with a header called "subdomain", a JSON body with the format we'll see in `TokenRequestWithCode` and the server will respond with a `TokenResponse`, which we'll see shortly as well. The API url for requesting auth tokens is `https://prod-in.100ms.live/hmsapi/get-token`

Here's a retrofit interface for how to request one.

```kotlin

    import retrofit2.http.Body
    import retrofit2.http.Header
    import retrofit2.http.POST

    interface HmsAuthTokenApi {

        @POST("https://prod-in.100ms.live/hmsapi/get-token")
        suspend fun getAuthToken(@Header("subdomain") subdomain : String,
                                @Body tokenRequestWithCode: TokenRequestWithCode
        ) : TokenResponse
    }

```

[Link in  sample repo.](https://github.com/100mslive/hello-world-android/blob/main/app/src/main/java/com/example/myvideocallapp/api/HmsAuthTokenApi.kt)


In this example, the retrofit api call is made off the main thread with a coroutine `suspend` function but it could be made with RxJava or whatever asynchronous call mechanism you prefer.

#### Subdomain
'Subdomain' is the subdomain of the video call joining link which you got from the dashboard. The value should be passed as a header in the API request with the key set to "subdomain".

For example if the link is https://myname.app.100ms.live/meeting/correct-horse-battery

Then the subdomain is: "myname.app.100ms.live". Here's an easy way to extract the subdomain.

```kotlin
    val meetingUrl = https://myname.app.100ms.live/meeting/correct-horse-battery
    val subDomain = java.net.URI(meetingUrl).host
```

The body of the request is a TokenRequestWithCode which is a class that looks like:

```kotlin
    data class TokenRequestWithCode constructor(
        @SerializedName("code") val code: String,
        @SerializedName("user_id") val userId: String = UUID.randomUUID().toString(),
    )
```

Where code is the meeting code. Meeting codes are determined from the video call joining links which you get from the dashboard.

For example if the link is: https://yourname.app.100ms.live/meeting/correct-horse-battery

Then the code is the string "correct-horse-battery".
Here's an easy function to extract it from the url:

```kotlin
    private fun getCodeFromMeetingUrl(meetingUrl: String) : String {
        val path = android.net.Uri.parse(meetingUrl).lastPathSegment!!
        return path
    }
```

userId can be any UUID and you let it autogenerate as seen above.

TokenResponse looks like:

```kotlin
    import com.google.gson.annotations.SerializedName

    data class TokenResponse(
        @SerializedName("token") val token: String
    )

```

Which means the server responds with a JSON object with the token key set to the token value.

Advanced:

The same room can have multiple links. On the [dashboard.100ms.live](dashboard) once you sign up you can define roles such as teachers or students each with their own privileges like being able to show video or not. Roles are yours to create and define!
One link can be given to students to join with their privileges and another to teachers to join with theirs.

#### Creating an HMSConfig instance

The username is whatever the user wants to called in the chat. You can ask this in the login screen.

```kotlin
// Create a new HMSConfig
val config = HMSConfig(
        username,
        authToken,
      )

```

username is the name that the user wants to be displayed while in the room.
authToken, is token retrieved from an auth token API call, this must be made each time the HMSConfig is created to join a room.

### Joining a Room

Requesting permissions:

Before you join a room, you'll need to add the following permissions to your manifest.

```xml
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
```

Since they're 'dangerous' level permissions, you'll have to request them at runtime as well.

[Here's](https://developer.android.com/training/permissions/requesting#allow-system-manage-request-code) the relevant Google guide for it.

With the username and authtoken retrieved, an HMSConfig instance can be created. Together with a new instance of the HMSUpdateListener interface you're ready to join a call.

### What Happens On Join

#### Audio
The SDK will automatically connect everyone's audio including streaming yours when join succeeds. Nothing more is required for audio.

#### Video
The video of participants is being sent over the network as well, but you need to render it to the screen.

What we're going for is for a view like this:
[todo add a video call grid with at least three participants]

We're going to use an [AndroidViewModel](https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel) to:
1. Receive the auth token that we got earlier.
2. Create an instance of `HMSSdk`.
3. Make a join call with the `HMSSdk` object.
4. Construct and listen to the `HMSUpdateListener` instance to keep track of people joining and leaving.


Each item on the screen will represent a video track.

We're going to show all videos in a grid recyclerview. The main components of which are:

1. The Recyclerview.
2. The adapter which contains the peers (people) `HMSPeer` and their video tracks `HMSVideoTrack` specifically.
3. The `PeerViewHolder` which will bind the items from the adapter into the video and text of each person's tile.

Separately we need to get information about our peers and their tracks to the adapter. This will come from the update listeners in the viewmodel.

Let's take a look at how to gather the list of information to display and then go into the recyclerview details.

Since peers can have multiple video tracks, such as their own video plus a screen share, what we're going to need is a list of items of type `TrackPeerMap` which will look like this.

Relevant sections are highlighted. The code is for the entire AndroidViewModel for video calls, named VideoCallVm.

```kotlin{2-5}

data class TrackPeerMap(
    val videoTrack: HMSVideoTrack?,
    val peer: HMSPeer
)

class VideoCallVm(authToken: String?, application: Application) : AndroidViewModel(application),
    HMSUpdateListener {

    private val _videoCallParticipants = MutableLiveData<List<TrackPeerMap>>(emptyList())
    val videoCallParticipants: LiveData<List<TrackPeerMap>> = _videoCallParticipants

    private val TAG = "VideoCallVm"

    private val hmsSdk = HMSSDK
        .Builder(application)
        .build()

    init {
        if (authToken != null) {
            Log.d(TAG, "Joining with $authToken")
            hmsSdk.join(HMSConfig("name", authToken), this)
        } else {
            Log.e(TAG, "There was an error since the auth token was null.")
        }
    }

    override fun onJoin(room: HMSRoom) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onMessageReceived(message: HMSMessage) {}
    override fun onRoleChangeRequest(request: HMSRoleChangeRequest) {}
    override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {}
    override fun onError(error: HMSException) {
        Log.d(TAG, "Error $error")
    }

    private fun getCurrentParticipants(): List<TrackPeerMap> {
        // Convert all the peers into a map of them and their tracks.
        val trackAndPeerMap = hmsSdk.getPeers().flatMap {
            val screenShare = it.auxiliaryTracks.find { auxTrack -> auxTrack is HMSVideoTrack }
            if (screenShare is HMSVideoTrack) {
                listOf(TrackPeerMap(it.videoTrack, it), TrackPeerMap(screenShare, it))
            } else {
                listOf(TrackPeerMap(it.videoTrack, it))
            }
        }

        return trackAndPeerMap
    }
}
```

We need a list of these in a LiveData that we'll update as people come and go and start and stop screenshares.

```kotlin{10-11}

data class TrackPeerMap(
    val videoTrack: HMSVideoTrack?,
    val peer: HMSPeer
)

class VideoCallVm(authToken: String?, application: Application) : AndroidViewModel(application),
    HMSUpdateListener {

    private val _videoCallParticipants = MutableLiveData<List<TrackPeerMap>>(emptyList())
    val videoCallParticipants: LiveData<List<TrackPeerMap>> = _videoCallParticipants

    private val TAG = "VideoCallVm"

    private val hmsSdk = HMSSDK
        .Builder(application)
        .build()

    init {
        if (authToken != null) {
            Log.d(TAG, "Joining with $authToken")
            hmsSdk.join(HMSConfig("name", authToken), this)
        } else {
            Log.e(TAG, "There was an error since the auth token was null.")
        }
    }

    override fun onJoin(room: HMSRoom) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onMessageReceived(message: HMSMessage) {}
    override fun onRoleChangeRequest(request: HMSRoleChangeRequest) {}
    override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {}
    override fun onError(error: HMSException) {
        Log.d(TAG, "Error $error")
    }

    private fun getCurrentParticipants(): List<TrackPeerMap> {
        // Convert all the peers into a map of them and their tracks.
        val trackAndPeerMap = hmsSdk.getPeers().flatMap {
            val screenShare = it.auxiliaryTracks.find { auxTrack -> auxTrack is HMSVideoTrack }
            if (screenShare is HMSVideoTrack) {
                listOf(TrackPeerMap(it.videoTrack, it), TrackPeerMap(screenShare, it))
            } else {
                listOf(TrackPeerMap(it.videoTrack, it))
            }
        }

        return trackAndPeerMap
    }
}
```
We'll have the AndroidViewModel implement HMSUpdateListener, create the hmsSDK and call join on it.

```kotlin{8,15-17,22}

data class TrackPeerMap(
    val videoTrack: HMSVideoTrack?,
    val peer: HMSPeer
)

class VideoCallVm(authToken: String?, application: Application) : AndroidViewModel(application),
    HMSUpdateListener {

    private val _videoCallParticipants = MutableLiveData<List<TrackPeerMap>>(emptyList())
    val videoCallParticipants: LiveData<List<TrackPeerMap>> = _videoCallParticipants

    private val TAG = "VideoCallVm"

    private val hmsSdk = HMSSDK
        .Builder(application)
        .build()

    init {
        if (authToken != null) {
            Log.d(TAG, "Joining with $authToken")
            hmsSdk.join(HMSConfig("name", authToken), this)
        } else {
            Log.e(TAG, "There was an error since the auth token was null.")
        }
    }

    override fun onJoin(room: HMSRoom) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onMessageReceived(message: HMSMessage) {}
    override fun onRoleChangeRequest(request: HMSRoleChangeRequest) {}
    override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {}
    override fun onError(error: HMSException) {
        Log.d(TAG, "Error $error")
    }

    private fun getCurrentParticipants(): List<TrackPeerMap> {
        // Convert all the peers into a map of them and their tracks.
        val trackAndPeerMap = hmsSdk.getPeers().flatMap {
            val screenShare = it.auxiliaryTracks.find { auxTrack -> auxTrack is HMSVideoTrack }
            if (screenShare is HMSVideoTrack) {
                listOf(TrackPeerMap(it.videoTrack, it), TrackPeerMap(screenShare, it))
            } else {
                listOf(TrackPeerMap(it.videoTrack, it))
            }
        }

        return trackAndPeerMap
    }
}
```

And since the viewmodel implements the listener it'll have to override the methods.

There are only three that we need to pay attention to for a barebones app:

1. onJoin - which notifies you when joining the room suceeded.
2. onTrackUpate - which is called when a video/audio/screenshare track is added to a peer or they mute/unmute.
3. onPeerUpdate - which notifies when a person joins or leaves the chat and more.

The rest are advaced cases which we can ignore in a quick start such as:

4. onMessageReceived - diplaying a chat.
5. onRoleChangeRequest - working with custom roles.
6. onRoomUpdate - being notified when the SDK mutes the room on incoming regular phone calls.
7. onError - if something went wrong during the chat.

```kotlin{28-38}

data class TrackPeerMap(
    val videoTrack: HMSVideoTrack?,
    val peer: HMSPeer
)

class VideoCallVm(authToken: String?, application: Application) : AndroidViewModel(application),
    HMSUpdateListener {

    private val _videoCallParticipants = MutableLiveData<List<TrackPeerMap>>(emptyList())
    val videoCallParticipants: LiveData<List<TrackPeerMap>> = _videoCallParticipants

    private val TAG = "VideoCallVm"

    private val hmsSdk = HMSSDK
        .Builder(application)
        .build()

    init {
        if (authToken != null) {
            Log.d(TAG, "Joining with $authToken")
            hmsSdk.join(HMSConfig("name", authToken), this)
        } else {
            Log.e(TAG, "There was an error since the auth token was null.")
        }
    }

    override fun onJoin(room: HMSRoom) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onMessageReceived(message: HMSMessage) {}
    override fun onRoleChangeRequest(request: HMSRoleChangeRequest) {}
    override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {}
    override fun onError(error: HMSException) {
        Log.d(TAG, "Error $error")
    }

    private fun getCurrentParticipants(): List<TrackPeerMap> {
        // Convert all the peers into a map of them and their tracks.
        val trackAndPeerMap = hmsSdk.getPeers().flatMap {
            val screenShare = it.auxiliaryTracks.find { auxTrack -> auxTrack is HMSVideoTrack }
            if (screenShare is HMSVideoTrack) {
                listOf(TrackPeerMap(it.videoTrack, it), TrackPeerMap(screenShare, it))
            } else {
                listOf(TrackPeerMap(it.videoTrack, it))
            }
        }

        return trackAndPeerMap
    }
}
```

The function `getCurrentRoomState` that all of those listeners is calling always does the same thing. It requests a list of active peers from the sdk and puts them in a TrackPeerMap that we saw before.

Anyone with a screenshare will get two tiles. One for their own video and one for the screenshare. Here it is.

```kotlin{47-59}

data class TrackPeerMap(
    val videoTrack: HMSVideoTrack?,
    val peer: HMSPeer
)

class VideoCallVm(authToken: String?, application: Application) : AndroidViewModel(application),
    HMSUpdateListener {

    private val _videoCallParticipants = MutableLiveData<List<TrackPeerMap>>(emptyList())
    val videoCallParticipants: LiveData<List<TrackPeerMap>> = _videoCallParticipants

    private val TAG = "VideoCallVm"

    private val hmsSdk = HMSSDK
        .Builder(application)
        .build()

    init {
        if (authToken != null) {
            Log.d(TAG, "Joining with $authToken")
            hmsSdk.join(HMSConfig("name", authToken), this)
        } else {
            Log.e(TAG, "There was an error since the auth token was null.")
        }
    }

    override fun onJoin(room: HMSRoom) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
        _videoCallParticipants.postValue(getCurrentParticipants())
    }

    override fun onMessageReceived(message: HMSMessage) {}
    override fun onRoleChangeRequest(request: HMSRoleChangeRequest) {}
    override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {}
    override fun onError(error: HMSException) {
        Log.d(TAG, "Error $error")
    }

    private fun getCurrentParticipants(): List<TrackPeerMap> {
        // Convert all the peers into a map of them and their tracks.
        val trackAndPeerMap = hmsSdk.getPeers().flatMap {
            val screenShare = it.auxiliaryTracks.find { auxTrack -> auxTrack is HMSVideoTrack }
            if (screenShare is HMSVideoTrack) {
                listOf(TrackPeerMap(it.videoTrack, it), TrackPeerMap(screenShare, it))
            } else {
                listOf(TrackPeerMap(it.videoTrack, it))
            }
        }

        return trackAndPeerMap
    }
}
```