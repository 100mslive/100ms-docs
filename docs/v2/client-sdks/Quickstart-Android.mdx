---
title: Quickstart - Android
nav: 10
---

## Introduction

Welcome to 100ms!

100ms makes an SDK (for android, ios and web) to abstract away the complexities of video conferencing. It helps  you to build your own video conferencing app.

Note: This is the guide for joining rooms without roles. For the meeting links created from the dashboard and not a custom server implementation.

## How it works end to end

This guide will help you create your own stunning video/audio conferencing app.

Here's an overview of what you'd do to get video conferencing working end to end.

1. Add the SDK to your app.
2. Build out the login and video room activities.
3. Sign up for your own dashboard @ [100ms](https://dashboard.100ms.live/register) to create meeting links.
    - Everyone who opens the link (from the app built with the SDK) joins the same video chat.

You can see the simplest android app repo that does this [here](https://github.com/100mslive/hello-world-android/).
Or see one with all the advanced features that 100ms has to offer [here](https://github.com/100mslive/100ms-android).

If you were looking for an audio and video preview after the login but before the video call, 100ms provides an API for that too. It's called the preview API and you'll find more info about it here [todo add link].

## Supported Android API Levels

100ms' Android SDK supports Android API level 21 and higher. It is built for armeabi-v7a, arm64-v8a, x86, and x86_64 architectures.

## Building the app

### Adding the SDK

#### 1. Add dependency to 100ms lib

-   Add the JitPack repository to your build file. Add it in your root `build.gradle` at the end of repositories of `allprojects`:

```json
allprojects {
		repositories {
			...
			maven { url 'https://jitpack.io' }
		}
	}
```
[todo mention that it needs to be added to settings.gradle instead]

-   Add the 100ms sdk dependency to your app-level `gradle` [![](https://jitpack.io/v/100mslive/android-sdk.svg)](https://jitpack.io/#100mslive/android-sdk)

```json
dependencies {
        // See the version in the jitpack badge above.
		implementation 'com.github.100mslive:android-sdk:x.x.x' 
	}
```

### 2. Add other dependencies

Add all the following libraries in your app-level Gradle file as dependencies.

-   If you are already using any of the following libraries (except for webrtc) in your application, you don't need to change the versions.
-   Make sure `webrtc` uses the same version as below.

```bash
implementation 'org.webrtc:google-webrtc:1.0.32006'
implementation 'com.squareup.okhttp3:okhttp:4.9.1'
implementation 'com.google.code.gson:gson:2.8.6'
implementation 'org.jetbrains:annotations:15.0'
```

That's the bare minimum, if you want to follow along with how to build an app you'll also need:

```bash
    // 100ms
    implementation 'org.webrtc:google-webrtc:1.0.32006'
    implementation 'com.github.100mslive:android-sdk:2.0.5' 

    // Networking
    implementation 'com.squareup.retrofit2:retrofit:2.9.0'
    implementation "com.squareup.okhttp3:okhttp:4.9.1"
    implementation 'com.google.code.gson:gson:2.8.7'
    implementation 'com.squareup.retrofit2:converter-gson:2.9.0'

    // Background handling
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'

    // Viewmodel
    implementation "androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1"
    // for by viewModels
    implementation "androidx.activity:activity-ktx:1.2.4"

    // Livedata
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.3.1"
```

### 3. Sign up to the dashboard

You'll need a 100ms account to create video rooms for you to join with the app.

[Sign up](https://dashboard.100ms.live/register) for an account. Be sure to create a video conferencing room and take note of the url. 

This is what we'll call the video call url and it should look something like this. https://yourname.app.100ms.live/preview/snippy-purple-mouse
<!-- [todo add video here] -->
<!-- ![](/docs/v2/getting-started-android/new-project-type.png) -->

## Create and instantiate 100ms SDK

To use the SDK methods, create an instance via the builder. Here's the simplest way.
```kotlin
val hmsSDK = HMSSDK
    .Builder(application) // pass the application context
    .build()
```

Advanced configurations can be seen at: [todo api reference].

## Joining a video call

To join a video chat you need to call the `join` method on HMSSDK. This method takes two parameters.
1. The HMSConfig (which contains username and authentication token as required parameters though advanced ones exist).
2. The HMSUpdateListeners which let you know when people join or leave or other things happen in the video chat.

It would look like:

```kotlin

    hmsSDK.join(hmsConfig, hmsUpdateListeners)

```

Let's see how to get instances of these objects.

#### Getting the HMSConfig ready

The only required fields in HMSConfig are username and authToken.

Username:
This can be whatever the user decides. Take it in a login form.

Auth Token:
A new auth token should be requested each time a call is joined.

The auth token API call is a HTTP POST call with a header called "subdomain", a JSON body with the format we'll see in `TokenRequestWithCode` and the server will respond with a `TokenResponse`, which we'll see shortly as well. The API url for requesting auth tokens is `https://prod-in.100ms.live/hmsapi/get-token`

Here's a retrofit interface for how to request one.

```kotlin

    import retrofit2.http.Body
    import retrofit2.http.Header
    import retrofit2.http.POST

    interface HmsAuthTokenApi {

        @POST("https://prod-in.100ms.live/hmsapi/get-token")
        suspend fun getAuthToken(@Header("subdomain") subdomain : String,
                                @Body tokenRequestWithCode: TokenRequestWithCode
        ) : TokenResponse
    }

```

[Link in  sample repo.](https://github.com/100mslive/hello-world-android/blob/main/app/src/main/java/com/example/myvideocallapp/api/HmsAuthTokenApi.kt)


In this example, the retrofit api call is made off the main thread with a coroutine `suspend` function but it could be made with RxJava or whatever asynchronous call mechanism you prefer.

#### Subdomain
'Subdomain' is the subdomain of the video call joining link which you got from the dashboard. The value should be passed as a header in the API request with the key set to "subdomain".

For example if the link is https://myname.app.100ms.live/meeting/correct-horse-battery

Then the subdomain is: "myname.app.100ms.live". Here's an easy way to extract the subdomain.

```kotlin
    val meetingUrl = https://myname.app.100ms.live/meeting/correct-horse-battery
    val subDomain = java.net.URI(meetingUrl).host
```

The body of the request is a TokenRequestWithCode which is a class that looks like:

```kotlin
    data class TokenRequestWithCode constructor(
        @SerializedName("code") val code: String,
        @SerializedName("user_id") val userId: String = UUID.randomUUID().toString(),
    )
```

Where code is the meeting code. Meeting codes are determined from the video call joining links which you get from the dashboard.

For example if the link is: https://yourname.app.100ms.live/meeting/correct-horse-battery

Then the code is the string "correct-horse-battery".
Here's an easy function to extract it from the url:

```kotlin
    private fun getCodeFromMeetingUrl(meetingUrl: String) : String {
        val path = android.net.Uri.parse(meetingUrl).lastPathSegment!!
        return path
    }
```

userId can be any UUID and you let it autogenerate as seen above.

TokenResponse looks like:

```kotlin
    import com.google.gson.annotations.SerializedName

    data class TokenResponse(
        @SerializedName("token") val token: String
    )

```

Which means the server responds with a JSON object with the token key set to the token value.

Advanced:

The same room can have multiple links. On the [dashboard.100ms.live](dashboard) once you sign up you can define roles such as teachers or students each with their own privileges like being able to show video or not. Roles are yours to create and define!
One link can be given to students to join with their privileges and another to teachers to join with theirs.

#### Creating an HMSConfig instance

The username is whatever the user wants to called in the chat. You can ask this in the login screen.

```kotlin
// Create a new HMSConfig
val config = HMSConfig(
        username,
        authToken,
      )

```

username is the name that the user wants to be displayed while in the room.
authToken, is token retrieved from an auth token API call, this must be made each time the HMSConfig is created to join a room.

### Joining a Room

Requesting permissions:

Before you join a room, you'll need to add the following permissions to your manifest.

```xml
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
```

Since they're 'dangerous' level permissions, you'll have to request them at runtime as well.

[Here's](https://developer.android.com/training/permissions/requesting#allow-system-manage-request-code) the relevant Google guide for it.

With the username and authtoken retrieved, an HMSConfig instance can be created. Together with a new instance of the HMSUpdateListener interface you're ready to join a call.

### What Happens On Join

#### Audio
The SDK will automatically connect everyone's audio including streaming yours when join succeeds. Nothing more is required for audio.

#### Video
The video of participants is being sent over the network as well, but you need to render it to the screen.

We're going to use an [AndroidViewModel](https://developer.android.com/reference/android/arch/lifecycle/AndroidViewModel) to:
1. Receive the auth token that we got earlier.
2. Create an instance of `HMSSdk`.
3. Make a join call with the `HMSSdk` object.
4. Construct and listen to the `HMSUpdateListener` instance to keep track of people joining and leaving.


Each item on the screen will represent a video track.

We're going to show all videos in a grid recyclerview. The main components of which are:

1. The Recyclerview.
2. The adapter which contains the peers (people) `HMSPeer` and their video tracks `HMSVideoTrack` specifically.


#### Audio calls only.
If you wanted only an audio call with no indication of who's there, it's enough to just call join with a default implementation of the interface.

So you might do:

```kotlin

            hmsSdk.join(
                HMSConfig("name", authToken),
                object : HMSUpdateListener {
                    override fun onError(error: HMSException) {}
                    override fun onJoin(room: HMSRoom) {}
                    override fun onMessageReceived(message: HMSMessage) {}
                    override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {}
                    override fun onRoleChangeRequest(request: HMSRoleChangeRequest) {}
                    override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {}
                    override fun onTrackUpdate(type: HMSTrackUpdate,track: HMSTrack,peer: HMSPeer) {}
                }
            )

```


## Add event listeners

100ms SDK provides callbacks to the client app about any change or update happening in the room after a user has joined by implementing `HMSUpdateListener` . These updates can be used to render the video on screen or to display other info regarding the room.

The main ones you need to know about to get up and running are:

1. `onJoin` which lets you know when you've joined the room.
2. `onPeerUpdate` which lets you know when someone else has joined the room.

`onPeerUpdate` also gives you a `HMSPeer` object from which you can get the remote person's audio and video.

// on join you can show the recyclerview.
// onPeerUpdate you can add people to the screen.

```kotlin
      val hmsUpdateListener = object: HMSUpdateListener{

        override fun onJoin(room: HMSRoom) {
          // This will be called on a successful JOIN of the room by the user
          // This is the point where applications can stop showing its loading state
        }

        override fun onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer) {
          // This will be called whenever there is an update on an existing peer
          // or a new peer got added/existing peer is removed.
          // This callback can be used to keep a track of all the peers in the room
        }

        override fun onRoomUpdate(type: HMSRoomUpdate, hmsRoom: HMSRoom) {
          // This is called when there is a change in any property of the Room
        }

        override fun onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer) {
          // This is called when there are updates on an existing track
          // or a new track got added/existing track is removed
          // This callback can be used to render the video on screen whenever a track gets added
        }

        override fun onMessageReceived(message: HMSMessage) {
          // This is called when there is a new broadcast message from any other peer in the room
          // This can be used to implement chat is the room
        }

        override fun onError(error: HMSException) {
          // This will be called when there is an error in the system
          // and SDK has already retried to fix the error
        }

        override fun onReconnecting(error: HMSException) {
          // This is called when connection reestablishment starts
          // This can be used to show a loading notification in the UI
          // Parameter error: the error from the action that failed and caused the connection reestablishment
        }

        override fun onReconnected() {
          // This is called when the connection reestablishment completed susccessfully
        }

      }
```

# STILL IN PROGRESS
