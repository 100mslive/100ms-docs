---
title: JavaScript Quickstart Guide
nav: 2.1
---

## Overview

Hello there! In this guide, we'll walk you through step-by-step instructions to create a  video conferencing application using the 100ms JavaScript SDK and test it locally on your device. In case you plan to use React, do check our [React quickstart](https://www.100ms.live/docs/javascript/v2/guides/react-quickstart) as well.

TL;DR - You can find the link to the complete example over [here](https://codesandbox.io/s/hms-js-quickstart-5rmes).

## Setup a local Javascript app
In this walkthrough, weâ€™ll use ParcelJS aÂ web application bundler that requires zero configuration. If you wish to use any other library or framework, you can set up your app using that. 

### Initialize a project
You can initialize a project using `npm init` or `yarn init`. While initializing the project you can enter the details for your project as you wish.

### Install Parcel
Then, install Parcel into your app using Yarn `yarn add --dev parcel` or when using npm run `npm install --save-dev parcel`.

### Project setup
Now that parcel is installed, letâ€™s create basic source files for our video-conferencing application. Letâ€™s create the files and folders in the below manner:

```
- index.html
- src
	-index.js
	-styles.css
```

## Add basic functionalities

### Initialize the SDK

Let us start with initializing the libraries. We need an instance of `HMSStore` and `HMSActions` to get started. Copy the code snippet below and paste it into your project.

```jsx:script.js
import {
  HMSReactiveStore,
  selectIsLocalAudioEnabled,
  selectIsLocalVideoEnabled,
  selectPeers,
  selectIsConnectedToRoom
} from "@100mslive/hms-video-store";

// Initialize HMS Store
const hmsManager = new HMSReactiveStore();
hmsManager.triggerOnSubscribe();
const hmsStore = hmsManager.getStore();
const hmsActions = hmsManager.getHMSActions();
```

`hmsStore` will hold the complete state of the application such as details of all the participants. We can also visualize this state at any time using the
[devtools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en) extension.

`hmsActions` will help us perform actions such as joining the room, mute our audio and send messages.

### Concepts

-   `Room`: When we join a conference call, the participants are said to be in a video call `room`.
-   `Peer`: A participant in the video call. You are the `local peer` while others are `remote peers`.
-   `Track`: Media. There are two types of track a peer can have - audio and video.

### Initialize the HTML elements
Now, let's initialize all the HTML elements required such as tile for local and remote peers, join and leave button, mute and unmute button, etc.

```jsx:script.js
// HTML elements
const form = document.getElementById("join");
const joinBtn = document.getElementById("join-btn");
const conference = document.getElementById("conference");
const peersContainer = document.getElementById("peers-container");
const leaveBtn = document.getElementById("leave-btn");
const muteAud = document.getElementById("mute-aud");
const muteVid = document.getElementById("mute-vid");
const controls = document.getElementById("controls");
```

### Join/leave a room

To join a room (a video call), we need to call the `join` method on `hmsActions` and it requires us to pass a `config` object.
The config object must be passed the following fields:

-   `userName`: The name of the user. This is the value that will be set on the `peer` object and be visible to everyone connected to the room.
-   `authToken`: A client-side token that is used to authenticate the user. You can read about how to generate this token [here](./token).

For our application, let us collect both of these fields from the user using a form.

Also, let's add a way to leave the room as well. We can call the `leave` method on `hmsActions` to leave the room. We'll set up the `leave` method to be called whenever the user closes the window or refreshes the tab.

<Tabs id="join-form" items={['HTML', 'JS']} />

<Tab id="join-form-0">

```html:index.html
<form id="join">
    <h2>Join Room</h2>
    <div class="input-container">
        <input id="name" type="text" name="username" placeholder="Your name" />
    </div>
    <div class="input-container">
        <input id="token" type="text" name="token" placeholder="Auth token" />
    </div>
    <button type="button" class="btn-primary" id="join-btn">Join</button>
</form>
```

</Tab>

<Tab id="join-form-1">

```jsx:script.js
// Joining the room
joinBtn.onclick = () => {
  hmsActions.join({
    userName: document.getElementById("name").value,
    authToken: document.getElementById("token").value
  });
};

// Leaving the room
function leaveRoom() {
  hmsActions.leave();
}

// Cleanup if user refreshes the tab or navigates away
window.onunload = window.onbeforeunload = leaveRoom;
leaveBtn.onclick = leaveRoom;
```
</Tab>

![Join room](/guides/join-room.png)

Congratulations! **you now have an audio-only conference ready to use**. If you have a friend join from another device, you can have a nice friendly chat with them.

### Render Local and remote peers

Let us next add a way to show a tile for every participant in the room. We'll need a list of peers connected to the room.

<Tabs id="render-peers" items={['JS', 'HTML']} />

<Tab id="render-peers-0">

```jsx:script.js
// helper function to create html elements
function createElementWithClass(tag, className) {
  const newElement = document.createElement(tag);
  newElement.className = className;
  return newElement;
}

// render a single peer
function renderPeer(peer) {
  const peerTileDiv = createElementWithClass("div", "peer-tile");
  const videoElement = createElementWithClass("video", "peer-video");
  const peerTileName = createElementWithClass("span", "peer-name");
  videoElement.autoplay = true;
  videoElement.muted = true;
  videoElement.playsinline = true;
  peerTileName.textContent = peer.name;
  hmsActions.attachVideo(peer.videoTrack, videoElement);
  peerTileDiv.append(videoElement);
  peerTileDiv.append(peerTileName);
  return peerTileDiv;
}

// display a tile for each peer in the peer list
function renderPeers() {
  peersContainer.innerHTML = "";
  const peers = hmsStore.getState(selectPeers);

  peers.forEach((peer) => {
    if (peer.videoTrack) {
      peersContainer.append(renderPeer(peer));
    }
  });
}

// reactive state - renderPeers is called whenever there is a change in the peer-list
hmsStore.subscribe(renderPeers, selectPeers);
```

</Tab>

<Tab id="render-peers-1">

```html:index.html
<div id="conference" class="conference-section hide">
    <h2>Conference</h2>
    <div id="peers-container"></div>
</div>
```

</Tab>

Now after you click join you should be able to see yourself!

![Web Conference](/guides/web-conference.png)

Since we are subscribed to the `peers` state, our tiles will be re-rendered any time a new peer joins or leaves the room.
**We have a fully functional video conferencing application now** ðŸŽ‰ðŸš€

### Mute/unmute local tracks

Right now we are publishing both audio and video feed of the user whenever they join the room.
We may want to allow the user to mute/unmute their own tracks - both audio and video.

Let's add 2 buttons on the bottom of the page and call the methods on `hmsActions` to mute/unmute the local tracks.

<Tabs id="mute-unmute" items={['JS', 'HTML']} />

<Tab id="mute-unmute-0">

```jsx:script.js
//Mute and unmute audio
muteAud.onclick = () => {
  const audioEnabled = !hmsStore.getState(selectIsLocalAudioEnabled);
  hmsActions.setLocalAudioEnabled(audioEnabled);
  muteAud.textContent = audioEnabled ? "Mute" : "Unmute";
};

//Mute and unmute video
muteVid.onclick = () => {
  const videoEnabled = !hmsStore.getState(selectIsLocalVideoEnabled);
  hmsActions.setLocalVideoEnabled(videoEnabled);
  muteVid.textContent = videoEnabled ? "Hide" : "Unhide";
  // Re-render video tile
  renderPeers();
};
```

</Tab>

<Tab id="mute-unmute-1">

```html
<div id="controls" class="control-bar">
    <button id="mute-aud" class="btn-control">Mute</button>
    <button id="mute-vid" class="btn-control">Hide</button>
</div>
```

</Tab>

We fetch the current state of the local audio and video and toggle them whenever the buttons are clicked.

![Mute/Unmute](/guides/mute-unmute.gif)

### Changing UI based on connection state

Right now, our join form shows even after we have joined the room. We need a way to know the connection state of the room and hide the form after we've connected.

We can do this by subscribing to the store with the `selectIsConnectedToRoom` selector.

```jsx:script.js
//Showing the required elements on connection/disconnection
function onConnection(isConnected) {
  if (isConnected) {
    form.classList.add("hide");
    conference.classList.remove("hide");
    leaveBtn.classList.remove("hide");
    controls.classList.remove("hide");
  } else {
    form.classList.remove("hide");
    conference.classList.add("hide");
    leaveBtn.classList.add("hide");
    controls.classList.add("hide");
  }
}

// listen to the connection state
hmsStore.subscribe(onConnection, selectIsConnectedToRoom);
```

## Test the app


## Next steps

Here's the complete example.

<Codesandbox id="5rmes" />

That wraps it up for this guide. We hope you had fun.
There are plenty of cool stuff which can be done with our SDK, be sure to check the [features section](/javascript/v2/features/integration) for more information.